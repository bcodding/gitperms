#! /usr/bin/perl

# git config --add remote.origin.fetch '+refs/tags/*:regs/tags/*'
# git config --add remote.origin.fetch '+refs/notes/*:refs/notes/*'
# git config --add remote.origin.push '+refs/heads/*:refs/heads/*'
# git config --add remote.origin.push '+refs/tags/*:refs/tags/*'
# git config --add remote.origin.push '+refs/notes/*:refs/notes/*'

use strict;
use warnings;

use Fcntl qw':mode S_ISDIR';
use File::Spec ();
use File::stat;  # overrides perl's stat and lstat
use File::Touch;
use Getopt::Long;
use IPC::Run3::Simple;
use Linux::Ext2::Attributes 'set_attrs';
use YAML;
use Unix::Mknod;

our $NOTE_NS = 'gitperms';  # What namespace are we using for notes?

my $topdir = get_toplevel();

chdir $topdir
  or die "Unable to change to git top level directory: $!\n";

GetOptions( save => \my $save, set => \my $set, quiet => \my $quiet )
  or die "Problem parsing options, exiting.\n";

die "either --save or --set is required\n"
  if ! defined $save && ! defined $set;

die "--save and --set are mutually exclusive\n"
  if defined $save && defined $set;

my %metadata;

# Get all files git knows about
run3( { cmd => [qw( git ls-tree -r -t HEAD )], stdout => \my @files } );

# Get unstaged files so we can ignore them
run3( { cmd => [qw( git status --porcelain --untracked-files=no )], stdout => \my @ignore } );

my %ignore; @ignore{ grep { s/^\s\S\s// } @ignore } = undef;

if ( defined $save ) {

  get_metadata_from_system();
  set_note();

} elsif ( defined $set ) {

  get_note();
  set_metadata_in_system()

} else {

  die "Unknown and unhandled error! How'd you get here?\n";

}

exit 0;

################################################################################################

sub get_toplevel {

  my ( $toplevel, $err, $syserr ) = run3( [qw( git rev-parse --show-toplevel )] );

  die "System error: $syserr\n"
    if $syserr;

  die "Unable to get top level directory: $err\n"
    if $err;

  $toplevel = File::Spec->canonpath( $toplevel );
  return $toplevel;

}

sub get_metadata_from_system {

  for my $f ( @files ) {

    my ( $sha1, $file ) = $f =~ /^\d+\s\w+\s([[:xdigit:]]+)\s(.*)$/;

    next if exists $ignore{ $file };

    my $md = $metadata{ $sha1 } ||= {};

    if ( my $st = lstat( $file ) ) {

      my $inode = $md->{ $st->ino } ||= {};

      my $ftype = ( $st->mode & 0170000 ) >> 12;

      $inode->{ type }
        = ( $st->rdev || $ftype == 1 || $ftype == 12 )                 ? 'CF'
        : ( ! S_ISDIR( $st->mode ) && $st->nlink > 1 && $inode != {} ) ? 'HL'
        : S_ISDIR( $st->mode )                                         ? 'DIR'
        : 'RF';

      $inode->{ $_ } = $st->$_ for qw( dev ino mode nlink uid gid rdev size atime mtime ctime blksize blocks );

      push @{ $inode->{ name } }, $file;

      if ( my $attributes = Linux::Ext2::Attributes->load( $file ) ) {

        $attributes = $attributes->strip;
        $inode->{ extnd_attr } = $attributes->flags;

      } else {

        ! defined $quiet && warn "Problem getting extended attributes on $file ($!).\n";

      }
    } else {

      ! defined $quiet && warn "Problem getting stat on $file ($!), skipping.\n";
      next;

    }
  } ## end for my $f ( @files)
} ## end sub get_metadata_from_system

sub set_metadata_in_system {

  for my $sha1 ( keys %metadata ) {

    my $md = $metadata{ $sha1 };

    for my $inode ( keys %$md ) {

      my $attr = $md->{ $inode };

      ! defined $quiet && warn "$sha1, $inode has multiple names, only the first one will be handled"
        if ( @{ $attr->{ name } } > 1 ) && ( $attr->{ type } ne 'HL' );

      my $name = shift @{ $attr->{ name } };

      warn "$name does not exist, skipping\n"
        if ( ! -e $name ) && ( $attr->{ type } ne 'HL' );

      if ( $attr->{ type } eq 'HL' ) {

        # Remove all but the first file
        # Hardlink removed files to first file.

        if ( @{ $attr->{ name } } == 0 ) {

          warn "No linked files (how did you get here?!), skipping\n";
          next;

        }

        my $files = join ', ', @{ $attr->{ name } };

        ! defined $quiet && warn "unlinking $files\n";

        my $removed = unlink @{ $attr->{ name } };

        warn "Unable to remove all files.\n"
          if $removed != @{ $attr->{ name } };

        ! defined $quiet && warn "Hardlinking $files to $name\n";

        for my $link ( @{ $attr->{ name } } ) {

          my $linked = link $name, $link;
          warn "Unable to link $name to $link: $!\n"
            unless $linked;

        }
      } elsif ( $attr->{ type } eq 'CF' ) {

        ( Unix::Mknod::mknod( $name, $attr->{ mode }, $attr->{ rdev } ) == -1 ) &&
          warn "Problem making special file $name: $!\n";

      } elsif ( $attr->{ type } eq 'DIR' ) {

        if ( ! -d $name ) {

          warn "$name exists and is not a directory, skipping\n";
          next;

        }

      } elsif ( $attr->{ type } ne 'RF' ) {

        ! defined $quiet && warn sprintf "Unknown file type or type note set for %s\n", join ', ', @{ $attr->{ name } };
        next;

      }

      chown_file( $name, $attr->{ uid }, $attr->{ gid } );
      chmod_file( $name, $attr->{ mode } );
      extnd_attr( $name, $attr->{ extnd_attr } );
      touch_file( $name, $attr->{ atime }, $attr->{ mtime } );

    }
  } ## end for my $sha1 ( keys...)
} ## end sub set_metadata_in_system

sub set_note {

  my @cmd = ( qw( git notes --ref ), $NOTE_NS, qw( add HEAD -m ) );

  my ( $out, $err ) = run3( [ @cmd, Dump( \%metadata ) ] );
  ! defined $quiet && warn "$out\n$err" if $err;

}

sub get_note {

  my @cmd = ( qw( git notes --ref ), $NOTE_NS, qw( show HEAD ) );
  my ( $out, $err ) = run3( \@cmd );

  warn $err if $err;

  %metadata = %{ Load( "$out\n" ) };

}

sub chmod_file {

  my ( $name, $mode ) = @_;

  ! defined $quiet && warn sprintf "chmod %04o, $name\n", $mode & 07777;

  my $chmodded = chmod +( $mode & 07777 ), $name;
  warn "Unable to change mode for $name: $!\n"
    unless $chmodded;

}

sub chown_file {

  my ( $name, $uid, $gid ) = @_;

  ! defined $quiet && warn "chown $uid, $gid, $name\n";

  my $chowned = chown $uid, $gid, $name;
  warn "Unable to change owner and/or group for $name: $!\n"
    unless $chowned == 1;

}

sub touch_file {

  my ( $name, $atime, $mtime ) = @_;

  ! defined $quiet && warn "touch -a $atime -m $mtime $name\n";

  my $t = File::Touch->new( atime => $atime, mtime => $mtime, no_create => 1 );

  $t->touch( $name )
    or warn "Unable to touch $name\n";

}

sub extnd_attr {

  my ( $name, $attr ) = @_;

  ! defined $quiet && warn "chattr $attr $name\n";
  set_attrs( $name, $attr )
    or warn "Unable to set extended attributes on $name\n";

}
