#! /usr/bin/perl

# http://rjbs.manxome.org/rubric/entry/1981 says File::Find is still the
# fastest, so we'll stick with that until something better comes along.

# Look into using File::ExtAttr to get/set extended attributes.
# Don't forget to ++1 them on metacpan if you end up using them.

use strict;
use warnings;

#use Data::Dumper ();
#use Fcntl ':mode';
#use File::Basename ();
#use File::Find ();
#use File::Spec ();
#use File::stat ':FIELDS'; # overrides perl's stat and lstat
#use IPC::Run3::Simple;
use Getopt::Long;

# Are we in a git repository?
# If not, die
# Are we running as post-commit or post-{checkout,merge}?
# If post-commit
#   get list of files being committed
#   for each file being committed
#     gather metadata
#     save metadata in note
# Else if post-{checkout,merge}
#   get list of files that were changed
#   for each file that changed
#     get metadata from note
#     modify metadata for file

chdir get_toplevel();
  or die "Unable to change to git top level directory: $!\n";

GetOptions(
  save => \my $save,
  set  => \my $set,
) or die "Problem parsing options, exiting.\n";

die "either --save or --set is required\n"
  if ! defined $save && ! defined $set;

die "--save and --set are mutually exclusive\n"
  if defined $save && defined $set;

if ( defined $save ) {

  my @files = run3([qw( git diff-tree HEAD )]);

} elsif ( defined $set ) {
} else {

  die "Unknown and unhandled error! How'd you get here?\n";

}

#my %format = (
#  RF => "%d\0%d\0%d\0%s\n",         # Regular file
#  CF => "CF: %d\0%d\0%d\0%d\0%s\n", # Character file
#  HL => "HL: %s\0%s\n",             # Hardlink
#);
#
##for my $file ( 
#my ( @metadata, %hardlink );
#
##File::Find::find({
##
##  'wanted'     => \&wanted,
##  'preprocess' => \&directories,
##  'no_chdir'   => 1,
##
##}, $base_dir );
#
##for my $hardlink ( keys %hardlink ) {
##
##  my $meta  = $hardlink{ $hardlink }{ 'meta' };
##  my $names = join "\0", @{ $hardlink{ $hardlink }{ 'names' } };
##  push @metadata, sprintf $format{ HL }, $meta, $names;
##
##}
#
#exit 0;
#
################################################################################################

sub get_toplevel {

  my ( $toplevel, $err, $syserr ) = run3([qw( git rev-parse --show-toplevel )]);

  die "System error: $syserr\n"
    if $syserr;

  die "Unable to get top level directory: $err\n"
    if $err;

  $toplevel = File::Spec->canonpath( $toplevel );
  return $toplevel;

}

#sub get_gitfiles {
#
#  run3({ cmd => [qw( git ls-files --full-name )], stdout => \my @gitfiles });
#  run3({ cmd => [qw( git config -f /.gitmodules --get-regexp ^submodule\..*\.path$ )], stdout => \my @submodules });
#
#  my %submodule = map { ( split /\s/ )[1], undef } @submodules;
#
#  # Directories are not explicitly handled in git, so we need to find the
#  # directories ourselves.
#
#  my %gitfile;
#
#  for my $file ( @gitfiles ) {
#
#    # submodules need to be handled differently, and is outside the scope of
#    # this script.
#
#    next if exists $submodule{ $file };
#
#    $gitfile{ $file } = undef;
#
#    my $dirname = File::Basename::dirname( $file );
#    next if $dirname eq '.';
#
#    # Is it faster to just reassaign the same value or to check for existence?
#    # next if exists $gitfile{ $dirname };
#
#    $gitfile{ $dirname } = undef;
#
#  }
#
#  return \%gitfile;
#
#}
#
#sub directories {
#
#  # Skip this repositories .git directory
#  if ( $File::Find::dir eq File::Spec->catfile( $base_dir, '.git' ) ) {
#
#    $File::Find::prune = 1;
#    return;
#
#  }
#
#  if ( $File::Find::dir ne $base_dir ) {
#
#    if ( lstat( $File::Find::dir ) ) {
#
#      my $dir = File::Spec->abs2rel( $File::Find::dir, $base_dir );
#
#      # If this directory isn't in the list of git files then skip it.
#      if ( ! exists $git_file->{ $dir } ) {
#
#        $File::Find::prune = 1;
#        return;
#
#      }
#
#      push @metadata, sprintf $format{ RF }, $st_uid, $st_gid, $st_mode, $dir;
#
#    } else {
#
#      warn "Problem getting stat on $File::Find::dir ($!), skipping.\n";
#      $File::Find::prune = 1;
#      return;
#
#    }
#  }
#
#  File::Spec->no_upwards( @_ );
#
#}
#
#sub wanted {
#
#  # We've already handled directories
#  return if -d $File::Find::name;
#
#  lstat( $File::Find::name ) or do {
#    warn "Problem getting stat on $File::Find::name ($!), skipping.\n";
#    return;
#  };
#
#  my $name = File::Spec->abs2rel( $File::Find::name, $base_dir );
#
#  # If it's not in git we don't care about it
#  return unless exists $git_file->{ $name };
#
#  my $ftype = ( $st_mode & 0170000 ) >> 12;
#
#  if ( $st_rdev || $ftype == 1 || $ftype == 12 ) {
#
#    # this is a character file
#
#    push @metadata, sprintf $format{ CF }, $st_uid, $st_gid, $st_mode, $st_rdev, $name;
#    return;
#
#  }
#
#  if ( $st_nlink > 1 ) {
#
#    # this is a hardlinked file
#
#    my $meta = sprintf "%d\0%d\0%d", $st_uid, $st_gid, $st_mode;
#
#    ( die sprintf "This shouldn't happen! $name is a hardlink and has different meta data ($meta) than %s\n", Data::Dumper::Dumper $hardlink{ $st_ino } )
#      if exists $hardlink{ $st_ino } && $meta ne $hardlink{ $st_ino }{ 'meta' };
#
#    $hardlink{ $st_ino }{ 'meta' } = $meta;
#    push @{ $hardlink{ $st_ino }{ 'names' } }, $name;
#    return;
#
#  }
#
#  push @metadata, sprintf $format{ RF }, $st_uid, $st_gid, $st_mode, $name;
#
#}
