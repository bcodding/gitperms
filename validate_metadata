#!/usr/bin/perl -w

# This file is expecting to be run from a git hook (at the moment, either
# post-checkout or post-merge).

use Carp;
use IPC::Run3::Simple;
use Text::Diff;
#use Unix::Mknod ':all';
use Unix::Mknod;

IPC::Run3::Simple::chomp_out( 1 );
IPC::Run3::Simple::default_stderr( \my $err );

run3({ 'cmd' => [qw( git rev-parse --show-toplevel )], 'stdout' => \my $base_dir });

chdir $base_dir
  or die "Unable to change to git top level directory: $!\n";

my $git_version = shift
  or die "Expecting a file to validate.\n";

die "Git version of metadata file does not exist\n"
  unless -e $git_version;

my $validate_file = '.validate_metafile';

run3( [ '.git/hooks/build_metafile', $validate_file ] );

die "$validate_file was not created"
  unless -e $validate_file;

my @diff = split /\n/, diff $validate_file, $git_version, { 'CONTEXT' => 0 };

if ( @diff == 0 ) {

  warn "Everything checks out, nothing to do.\n";
  exit 0;

}

croak "Incorrect order in diff ($validate_file should be first) or something else is wrong\n"
  unless ( shift @diff ) =~ /--- $validate_file/;

croak "Incorrect order in diff ($git_version should be second) or something else is wrong\n"
  unless ( shift @diff ) =~ /\+\+\+ $git_version/;

for my $fix ( @diff ) {

  next unless $fix =~ s/^\+//;

  if ( $fix =~ s/^HL: // ) {

    my ( $uid, $gid, $mode, $name, @links ) = split /\0/, $fix;

    # XXX: Check for non-existant files.

    if ( @links > 0 ) {

      my $links = join ' ', @links;

      warn "Deleting $links\n";
      my $removed = unlink @links;
      warn "Unable to remove all files.\n"
        if $removed != @links;

      warn "Hardlinking $links to $name\n";
      link $name, $_ for @links;

    }

    chmod_file( $name, $mode );
    chown_file( $name, $uid, $gid );

  } elsif ( $fix =~ s/^CF: // ) {

    my ( $uid, $gid, $mode, $rdev, $name ) = split /\0/, $fix;

    ( Unix::Mknod::mknod( $name, $mode, $rdev ) == -1 ) &&
      warn "Problem making special file $name: $!\n";

    chown_file( $name, $uid, $gid );

  } else {

    my ( $uid, $gid, $mode, $name ) = split /\0/, $fix;

    if ( -e $name ) {

      chmod_file( $name, $mode );
      chown_file( $name, $uid, $gid );

    } else {

      warn "$name does not exist, skipping.\n";
      next;

    }
  }
}

unlink $validate_file
  or warn "Unable to remove $validate_file: $!\n";


sub chmod_file {

  my ( $name, $mode ) = @_;

  $mode = sprintf '%04o', $mode & 07777;

  warn "chmod $mode, $name\n";

  my $chmodded = chmod $mode, $name;
  warn "Unable to change mode for $name: $!\n"
    unless $chmodded;

}

sub chown_file {

  my ( $name, $uid, $gid ) = @_;

  warn "chown $uid, $gid, $name\n";

  my $chowned = chown $uid, $gid, $name;
  warn "Unable to change owner and/or group for $name: $!\n"
    unless $chowned == 1;

}
