#! /usr/bin/perl

eval 'exec /usr/bin/perl -S $0 ${1+"$@"}' if 0;

use strict;
use warnings;
#no warnings 'File::Find';

use Data::Dumper ();
use Fcntl ':mode';
use File::Find ();
use File::Spec ();
use File::stat ':FIELDS';
use IPC::Run3::Simple;

IPC::Run3::Simple::croak_on_err( 1 );
IPC::Run3::Simple::chomp_out( 1 );
IPC::Run3::Simple::default_stderr( \my $err );

run3({ 'cmd' => [qw( git rev-parse --show-toplevel )], 'stdout' => \my $base_dir });

$base_dir = File::Spec->canonpath( $base_dir );

chdir $base_dir
  or die "Unable to change to git top level directory: $!\n";

run3({ 'cmd' => [qw( git ls-files )], 'stdout' => \my @git_files });
my %git_file; @git_file{ @git_files } = undef;

my $metafile = shift
  or die "Expecting file to save metadata to.\n";

open my $METAFILE, '>', $metafile
  or die "Unable to open $metafile for writing: $!\n";

my ( %inode, @rdev );

File::Find::find({

  'wanted'     => \&wanted,
  'preprocess' => \&directories,
  'no_chdir'   => 1,

}, $base_dir );

print $METAFILE $_
  for @rdev;

for my $inode ( keys %inode ) {

  my $meta  = $inode{ $inode }{ 'meta' };
  my $names = join "\0", @{ $inode{ $inode }{ 'names' } };
  printf $METAFILE "HL: %s\0%s\n", $meta, $names;

}

exit 0;

sub directories {

  if ( $File::Find::dir eq File::Spec->catfile( $base_dir, '.git' ) ) {

    $File::Find::prune = 1;
    return;

  }

  if ( $File::Find::dir ne $base_dir ) {

    if ( lstat( $File::Find::dir ) ) {

      if ( ! $st_dev || $st_dev != $File::Find::topdev ) {

        $File::Find::prune = 1;
        return;

      }

      my $dir = File::Spec->abs2rel( $File::Find::dir, $base_dir );

      printf $METAFILE "%d\0%d\0%d\0%s\n", $st_uid, $st_gid, $st_mode, $dir;

    } else {

      warn "Problem getting stat on $File::Find::dir ($!), skipping.\n";

    };
  }

  File::Spec->no_upwards( @_ );

}

sub wanted {

  lstat( $File::Find::name ) or do {
    warn "Problem getting stat on $File::Find::name ($!), skipping.\n";
    return;
  };

  if ( ! $st_dev || $st_dev != $File::Find::topdev ) {

    $File::Find::prune = 1;
    return;

  }

  my $name = File::Spec->abs2rel( $File::Find::name, $base_dir );

  if ( $st_rdev ) {

    my $meta = sprintf "CF: %d\0%d\0%d\0%d\0%s\n", $st_uid, $st_gid, $st_mode, $st_rdev, $name;
    push @rdev, $meta;
    return;

  }

  return unless exists $git_file{ $name };

  if ( $st_nlink > 1 ) {

    my $meta = sprintf "%d\0%d\0%d", $st_uid, $st_gid, $st_mode;

    ( die sprintf "This shouldn't happen! $name is a hardlink and has different meta data ($meta) than %s\n", Data::Dumper::Dumper $inode{ $st_ino } )
      if exists $inode{ $st_ino } && $meta ne $inode{ $st_ino }{ 'meta' };

    $inode{ $st_ino }{ 'meta' } = $meta;
    push @{ $inode{ $st_ino }{ 'names' } }, $name;
    return;

  }

  printf $METAFILE "%d\0%d\0%d\0%s\n", $st_uid, $st_gid, $st_mode, $name;

}
